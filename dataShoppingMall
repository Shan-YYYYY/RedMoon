//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

contract DataShoppingMall{
/**
DataListForSeler 记录卖家卖的商品信息
DaoOrganizationAddress 不变，可信Dao地址
NumberOfData 总订单号
*/
//address DaoOrganizationAddress = 等待确认
mapping(address => mapping(uint256 => Data)) public DataListForSeler;

uint256 public  NumberOfTotalData;
    constructor() payable {

    }
    /**
    商品结构体
@Owner
@NameOfData   个体订单号
@ValueOfData
@PhotoOfData
@TypesOfData  预分类
@IntroduceOfData
@BondOfData
@Linkhash
@TotalCustomer  总售出量

@CustomerList   保存顾客地址数组
@EncodeLinkList 对应加密链接数组                          两者个构成一个 address => string

@CustomerTimeList  记录锁币时间数组(卖家发货开始计算 一天)
@NewSubscriptOfsend         记录最新一个未发送顾客的下标
@NewSubscriptOfCustomerList 记录最新一个未提币顾客的下标
@Timestamp  上架时间
@IsLockByDao 
@IsLockBySeller
@SelfDistroytime 下架倒计时一天
@AddressOfComplaint 质疑顾客
*/
    struct Data{
        address Owner;
        uint256 NumberOfData;
        string NameOfData;
        uint256 ValueOfData;
        string PhotoOfData;
        bool[4] TypesOfData;
        string IntroduceOfData;
        uint256 BondOfData;
        string Linkhash;
        uint256 TotalCustomer;
        address[] CustomerList;
        string[] EncodeLinkList;
        uint256 NewSubscriptOfCustomerList;
        uint256[] CustomerTimeList;
        uint256 NewSubscriptOfsend;
        uint256 Timestamp;
        bool IsLockByDao;
        bool IsLockBySeller;
        uint256 SelfDistroytime;
        address AddressOfComplaint;
    }
    Data data;
    //上架功能
    function CommodityListing(
        string memory _NameOfData,
        uint256  _ValueOfData,
        string memory _PhotoOfData,
        bool[4] memory _TypesOfData,
        string memory _IntroduceOfData,
        uint256  _BondOfData,
        string memory _Linkhash
        )
        payable  external returns(bool)
        {
            require(msg.value == _BondOfData && msg.value == _ValueOfData*10, "not enough Bond");
            //结构体初始化
            Data storage _data = data;
            //加入映射再更改值
            _data = DataListForSeler[msg.sender][NumberOfTotalData];
            NumberOfTotalData++;
            _data.Owner = msg.sender;
            _data.NumberOfData = NumberOfTotalData;
            NumberOfTotalData++;             
            _data.NameOfData = _NameOfData;
            _data.ValueOfData = _ValueOfData;
            _data.PhotoOfData = _PhotoOfData;
            _data.TypesOfData = _TypesOfData;
            _data.IntroduceOfData = _IntroduceOfData;
            _data.BondOfData = _BondOfData;
            _data.Linkhash = _Linkhash;
            _data.CustomerList;
            _data.NewSubscriptOfCustomerList;
            _data.Timestamp = block.timestamp;
            _data.IsLockByDao;
            _data.IsLockBySeller;
            _data.SelfDistroytime;
        return true;
    }


    //买家购买,钱转到合约   当前订单定位 DataListForSeler[_Owner][_NumberOfData]
    function CommodityBuying(
        address _Owner,
        uint256 _NumberOfData
    )payable  external returns(bool){
        //购买条件确认
        require(msg.value == DataListForSeler[_Owner][_NumberOfData].ValueOfData, "you do not pay enough money");
        require(DataListForSeler[_Owner][_NumberOfData].IsLockByDao == true, "this data is lock by dao");
        require(DataListForSeler[_Owner][_NumberOfData].IsLockBySeller == true, "this data is lock by seller");
        //添加买家地址到购买者名单中
    DataListForSeler[_Owner][_NumberOfData].CustomerList.push(msg.sender);
    DataListForSeler[_Owner][_NumberOfData].TotalCustomer++;
    return true;
    }

    //卖家发货,并开始锁币倒计时 
    function TransferLink(
        address _Owner,
        uint256 _NumberOfData,
        string[] memory EncodeLink
    )external returns(bool)
    {
      //上传链接到CustomerList并开始锁币倒计时
      uint256 _NewSubscriptOfsend = DataListForSeler[msg.sender][_NumberOfData].NewSubscriptOfsend;
      for(uint i = _NewSubscriptOfsend;_NewSubscriptOfsend <= EncodeLink.length-1;_NewSubscriptOfsend++){
        DataListForSeler[msg.sender][_NumberOfData].EncodeLinkList[_NewSubscriptOfsend] = EncodeLink[_NewSubscriptOfsend];
        DataListForSeler[msg.sender][_NumberOfData].CustomerTimeList.push(block.timestamp);
        }
        //更新发送下标
        DataListForSeler[msg.sender][_NumberOfData].NewSubscriptOfsend = _NewSubscriptOfsend;
        return true;
    }

    //卖家提被锁的币  当前订单定位DataListForSeler[msg.sender][_NumberOfData]  或10倍售价的释放保证金
    function ReleaseLockmoney(
        uint _NumberOfData
    )payable  external returns(bool){
       require(DataListForSeler[msg.sender][_NumberOfData].IsLockByDao == false, "data is arbitrating");
       uint _NumberOfMoney;
       if(DataListForSeler[msg.sender][_NumberOfData].IsLockBySeller == true && block.timestamp - DataListForSeler[msg.sender][_NumberOfData].SelfDistroytime > 86400)
       {
        _NumberOfMoney = 10;
        //防止重入
        DataListForSeler[msg.sender][_NumberOfData].IsLockByDao = true;
       }
       uint _NewSubscr = DataListForSeler[msg.sender][_NumberOfData].NewSubscriptOfCustomerList;
       for(uint256 i = _NewSubscr;;i++){
        if(block.timestamp - DataListForSeler[msg.sender][_NumberOfData].CustomerTimeList[i] > 86400){
            _NumberOfMoney++;
        }else {
            //更新新顾客下标
            DataListForSeler[msg.sender][_NumberOfData].NewSubscriptOfCustomerList = i;
            break;
        }
        //转钱给卖家
        payable (msg.sender).transfer(_NumberOfMoney*DataListForSeler[msg.sender][_NumberOfData].ValueOfData);
        }
        return true;
        }


        //卖家撤销商品,并开始下架倒计时
        function RevokeData(
            uint _NumberOfData
        )
        external returns(bool){
            require(DataListForSeler[msg.sender][_NumberOfData].IsLockByDao == true, "data is arbitrating");
            DataListForSeler[msg.sender][_NumberOfData].SelfDistroytime = block.timestamp;
        }


        //买家质疑link有问题，提出投诉
        function  Complaint(
            address _Owner,
            uint256 _NumberOfData,
            string memory _Link
        )payable external returns(bool){
            require(DataListForSeler[_Owner][_NumberOfData].IsLockByDao == false && 
            block.timestamp - DataListForSeler[msg.sender][_NumberOfData].SelfDistroytime > 86400,"tnis data is already done");
            //提供对赌金 2倍售价
            require(msg.value == DataListForSeler[_Owner][_NumberOfData].ValueOfData*2,"you do not pay enough for bond");
            //锁合约，标注顾客身份
            DataListForSeler[_Owner][_NumberOfData].IsLockByDao = true;
            DataListForSeler[_Owner][_NumberOfData].AddressOfComplaint = msg.sender;

            //调用dao组织合约*

            return true;
        }

        //dao组织反馈
        function DaoDeciding(
            address _Owner,
            uint256 _NumberOfData,
            bool _IsDataTrue
        )payable external returns(bool){
//            require(msg.sender == DaoOrganizationAddress);
            uint256 _ValueOfData = DataListForSeler[_Owner][_NumberOfData].ValueOfData;
            if(_IsDataTrue == false){
                //返还对赌金
            payable (DataListForSeler[_Owner][_NumberOfData].AddressOfComplaint).transfer(_ValueOfData*2);
            //返还购买金额
            uint256 _NumberOfReturn =  this.Compute(_Owner,_NumberOfData);
            uint256 _NewSubscriptOfCustomerList = DataListForSeler[_Owner][_NumberOfData].NewSubscriptOfCustomerList;

            for(uint i = _NewSubscriptOfCustomerList;;i++){
                payable (DataListForSeler[_Owner][_NumberOfData].CustomerList[_NewSubscriptOfCustomerList]).transfer(_ValueOfData + _NumberOfReturn);
            }
            }else{
            DataListForSeler[_Owner][_NumberOfData].IsLockByDao = false;
            }
            return true;
        }
        
        //查询NumberOfData
        function FindNumberOfTotalData(
        )view  external returns(uint){
        return  NumberOfTotalData;
        }
        //查询Linkhash
        function FindLinkhash(
            address  _Owner,
            uint256 _NumberOfData
        )view  external returns(string memory){
        return  DataListForSeler[_Owner][_NumberOfData].Linkhash;
        }
        //计算返还钱的数量
        function  Compute(
            address _Owner,
            uint256 _NumberOfData
        )view  external returns(uint){
         return   DataListForSeler[_Owner][_NumberOfData].BondOfData/(DataListForSeler[_Owner][_NumberOfData].TotalCustomer - DataListForSeler[_Owner][_NumberOfData].NewSubscriptOfCustomerList);
        }

    }
